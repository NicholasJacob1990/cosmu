"""\nTarefas Celery para coletar e calcular academic_score.\nExecutar manualmente:  refresh_academic_score.delay(prof.id)\nOu agendar no beat semanal.\n"""\nimport os, requests, hashlib, redis, bs4\nfrom celery import shared_task\nfrom django.utils import timezone\nfrom apps.profiles.models import Professional\nfrom apps.search.tasks import index_professional\n\nR = redis.Redis.from_url(os.getenv(\"CELERY_BROKER_URL\", \"redis://redis:6379/0\"))\n\n# ────────────────────────────────────────────────────────────────\n#  TASK PRINCIPAL\n# ────────────────────────────────────────────────────────────────\n@shared_task(bind=True, max_retries=3, default_retry_delay=300)\ndef refresh_academic_score(self, prof_id: int):\n    try:\n        prof = Professional.objects.get(pk=prof_id)\n    except Professional.DoesNotExist:\n        return\n\n    # 1. Prioridade: ORCID ▸ Lattes ▸ LinkedIn público\n    raw = (fetch_orcid(prof.orcid_id)\n           or fetch_lattes(prof.lattes_id)\n           or fetch_linkedin_by_email(prof.user.email))\n\n    if not raw:\n        return\n\n    # 2. Regra de negócio – mix grau × ranking universidade\n    level_map = {\"PhD\": 1.0, \"Doutorado\": 1.0,\n                 \"MSc\": 0.8, \"Mestrado\": 0.8,\n                 \"BSc\": 0.6, \"Bacharelado\": 0.6,\n                 \"Tecnologo\": 0.4, \"Tecnólogo\": 0.4}\n\n    degree   = raw[\"degree\"]\n    rank_pos = raw[\"university_rank\"] or 1000\n\n    prof.degree_level    = degree\n    prof.university_rank = rank_pos\n    prof.academic_score  = (level_map.get(degree, .3) * 0.7\n                            + max(0, 1 - rank_pos / 1000) * 0.3)    # 0-1\n    prof.save(update_fields=[\"degree_level\", \"university_rank\",\n                             \"academic_score\", \"updated_at\"])\n\n    # 3. Re-indexa no OpenSearch\n    index_professional.delay(prof.id)\n\n\n@shared_task\ndef refresh_all_academic_scores():\n    \"\"\"Task semanal para atualizar todos os profissionais.\"\"\"\n    for prof in Professional.objects.filter(\n        models.Q(orcid_id__isnull=False) | \n        models.Q(lattes_id__isnull=False)\n    ).exclude(\n        models.Q(orcid_id=\"\") & models.Q(lattes_id=\"\")\n    ):\n        refresh_academic_score.delay(prof.pk)\n\n\n# ────────────────────────────────────────────────────────────────\n#  Adaptadores de fontes externas (simplificados)\n# ────────────────────────────────────────────────────────────────\ndef fetch_orcid(orcid):\n    if not orcid:\n        return None\n    url = f\"https://pub.orcid.org/v3.0/{orcid}/educations\"\n    headers = {\"Accept\": \"application/json\"}\n    try:\n        resp = requests.get(url, headers=headers, timeout=15).json()\n        edu  = resp[\"educations\"][\"education-summary\"][0]\n        uni  = edu[\"organization\"][\"name\"]\n        degree = edu.get(\"role-title\", \"BSc\")\n        rank = qs_rank(uni)\n        return {\"degree\": degree, \"university_rank\": rank}\n    except Exception:\n        return None\n\n\ndef fetch_lattes(lattes_id):\n    if not lattes_id:\n        return None\n    try:\n        html = requests.get(f\"https://lattes.cnpq.br/{lattes_id}\",\n                            timeout=20).text\n        soup = bs4.BeautifulSoup(html, \"html.parser\")\n        degree = soup.select_one(\".titulo-doutorado,.titulo-mestrado,\"\n                                 \".titulo-graduacao\").text.strip()\n        uni = soup.select_one(\".instituicao\").text.strip()\n        rank = qs_rank(uni)\n        return {\"degree\": degree, \"university_rank\": rank}\n    except Exception:\n        return None\n\n\ndef fetch_linkedin_by_email(email):\n    \"\"\"Busca perfil público via ScrapingBee ou API de enrichment.\"\"\"\n    token = os.getenv(\"SCRAPINGBEE_KEY\")\n    if not token:\n        return None\n    try:\n        domain = email.split(\"@\")[1]\n        resp = requests.get(\"https://app.scrapingbee.com/api/v1/\",\n                            params={\"api_key\": token,\n                                    \"url\": f\"https://www.linkedin.com/sales/gmail/profile/{email}\",\n                                    \"render_js\": \"false\"},\n                            timeout=20)\n        if resp.status_code != 200:\n            return None\n        soup = bs4.BeautifulSoup(resp.text, \"html.parser\")\n        degree = soup.select_one(\".degree\").text.strip()\n        uni = soup.select_one(\".university\").text.strip()\n        rank = qs_rank(uni)\n        return {\"degree\": degree, \"university_rank\": rank}\n    except Exception:\n        return None\n\n\ndef qs_rank(university):\n    \"\"\"\n    Consulta ranking QS; resultado cacheado 30 dias em Redis.\n    \"\"\"\n    key = f\"qs:{hashlib.md5(university.encode()).hexdigest()}\"\n    cached = R.get(key)\n    if cached:\n        return int(cached)\n\n    try:\n        resp = requests.get(\"https://api.qsranking.com/v1/search\",\n                            params={\"q\": university}, timeout=10).json()\n        rank = resp[\"results\"][0][\"rank\"]\n    except Exception:\n        rank = 1000\n    R.setex(key, 2_592_000, rank)   # 30 dias\n    return rank