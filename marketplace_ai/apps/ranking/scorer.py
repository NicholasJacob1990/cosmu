"""\nCombina features normalizadas com pesos configuráveis.\n\n* load_weights()    — carrega da tabela RankingWeight\n* compute_score()   — soma ponderada das features\n* rank_hits()       — aplica scorer a lista de hits\n"""\nfrom __future__ import annotations\n\nfrom typing import Dict, List, Any\nfrom django.core.cache import cache\n\nfrom .models import RankingWeight\nfrom .feature_builder import build_features\n\n\ndef load_weights() -> Dict[str, float]:\n    \"\"\"\n    Carrega pesos do banco com cache de 5 min.\n    Se não houver peso configurado, usa padrão 1.0.\n    \"\"\"\n    weights = cache.get(\"ranking_weights\")\n    if weights is None:\n        weights = dict(RankingWeight.objects.values_list(\"name\", \"value\"))\n        cache.set(\"ranking_weights\", weights, 300)  # 5 min\n    \n    # Defaults para features principais\n    defaults = {\n        \"sim_semantico\": 1.0,\n        \"score_confianca\": 0.8,\n        \"score_avaliacao\": 0.9,\n        \"score_engajamento\": 0.7,\n        \"score_proximidade\": 0.6,\n        \"score_qualificacao\": 0.5,\n    }\n    \n    for key, default_val in defaults.items():\n        if key not in weights:\n            weights[key] = default_val\n            \n    return weights\n\n\ndef compute_score(features: Dict[str, float]) -> float:\n    \"\"\"\n    Calcula score final como soma ponderada das features.\n    \n    Score = Σ(weight_i * feature_i)\n    \"\"\"\n    weights = load_weights()\n    score = 0.0\n    \n    for feat_name, feat_val in features.items():\n        weight = weights.get(feat_name, 0.0)\n        score += weight * feat_val\n        \n    return max(0.0, score)  # garante não-negativo\n\n\ndef rank_hits(\n    hits: List[Dict[str, Any]], \n    user_coords: tuple[float, float] | None = None\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Aplica re-ranking heurístico aos hits do OpenSearch.\n    \n    1. Extrai features de cada hit\n    2. Calcula score combinado\n    3. Ordena por score decrescente\n    4. Adiciona campo 'final_score' em cada hit\n    \"\"\"\n    scored_hits = []\n    \n    for hit in hits:\n        features = build_features(hit, user_coords)\n        final_score = compute_score(features)\n        \n        # Adiciona score e features ao hit\n        hit[\"final_score\"] = final_score\n        hit[\"features\"] = features\n        scored_hits.append(hit)\n    \n    # Ordena por score decrescente\n    scored_hits.sort(key=lambda x: x[\"final_score\"], reverse=True)\n    \n    return scored_hits